import { createClient } from 'npm:@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

interface ScanRequest {
  sha256Hash: string;
  fileName: string;
  fileSize: number;
  fileContent?: string;
}

interface ScanResult {
  fileHashId: string;
  overallVerdict: 'safe' | 'suspicious' | 'malicious' | 'critical';
  threatScore: number;
  hashCheckResult: any;
  heuristicResult: any;
  staticAnalysisResult: any;
  behavioralAnalysisResult: any;
  externalSources: any;
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Check for required environment variables
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    
    if (!supabaseUrl) {
      throw new Error('SUPABASE_URL environment variable is not set');
    }
    
    if (!supabaseServiceRoleKey) {
      throw new Error('SUPABASE_SERVICE_ROLE_KEY environment variable is not set');
    }

    const supabase = createClient(
      supabaseUrl,
      supabaseServiceRoleKey
    );

    const { sha256Hash, fileName, fileSize, fileContent }: ScanRequest = await req.json();

    // Layer 1: Hash Database Check
    const hashCheckResult = await performHashCheck(supabase, sha256Hash);
    
    // Layer 2: Heuristic Analysis
    const heuristicResult = await performHeuristicAnalysis(fileName, fileSize);
    
    // Layer 3: Static Analysis
    const staticAnalysisResult = await performStaticAnalysis(supabase, fileContent || '', fileName);
    
    // Layer 4: Behavioral Analysis (Hybrid Analysis API)
    const behavioralAnalysisResult = await performBehavioralAnalysis(sha256Hash);

    // Calculate overall threat score and verdict
    const threatScore = calculateThreatScore(hashCheckResult, heuristicResult, staticAnalysisResult, behavioralAnalysisResult);
    const overallVerdict = determineVerdict(threatScore);

    // If no external behavioral analysis is available, determine verdict based on other analyses
    if (!behavioralAnalysisResult.found) {
      behavioralAnalysisResult.verdict = determineBehavioralVerdict(hashCheckResult, heuristicResult, staticAnalysisResult, overallVerdict);
      behavioralAnalysisResult.found = true; // Mark as found so it displays
      behavioralAnalysisResult.note = 'Verdict determined from comprehensive analysis';
    }

    // Store or update file hash record
    const { data: fileHashData, error: fileHashError } = await supabase
      .from('file_hashes')
      .upsert({
        sha256_hash: sha256Hash,
        file_name: fileName,
        file_size: fileSize,
        file_extension: getFileExtension(fileName),
        last_seen: new Date().toISOString(),
        scan_count: 1
      }, {
        onConflict: 'sha256_hash',
        ignoreDuplicates: false
      })
      .select()
      .single();

    if (fileHashError) {
      throw fileHashError;
    }

    // Store scan result
    const scanResult: ScanResult = {
      fileHashId: fileHashData.id,
      overallVerdict,
      threatScore,
      hashCheckResult,
      heuristicResult,
      staticAnalysisResult,
      behavioralAnalysisResult,
      externalSources: hashCheckResult.externalSources || {}
    };

    const { data: scanResultData, error: scanError } = await supabase
      .from('scan_results')
      .insert({
        file_hash_id: scanResult.fileHashId,
        overall_verdict: scanResult.overallVerdict,
        threat_score: scanResult.threatScore,
        hash_check_result: scanResult.hashCheckResult,
        heuristic_result: scanResult.heuristicResult,
        static_analysis_result: scanResult.staticAnalysisResult,
        behavioral_analysis_result: scanResult.behavioralAnalysisResult,
        external_sources: scanResult.externalSources
      })
      .select()
      .single();

    if (scanError) {
      throw scanError;
    }

    return new Response(
      JSON.stringify({
        success: true,
        scanId: scanResultData.id,
        result: scanResult
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Scan error:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});

async function performHashCheck(supabase: any, sha256Hash: string) {
  try {
    // Check local database first
    const { data: localData } = await supabase
      .from('file_hashes')
      .select('*, scan_results(*)')
      .eq('sha256_hash', sha256Hash)
      .order('scan_timestamp', { ascending: false })
      .limit(1);

    if (localData && localData.length > 0) {
      const latestScan = localData[0].scan_results[0];
      return {
        found: true,
        source: 'local',
        verdict: latestScan?.overall_verdict || 'unknown',
        lastSeen: localData[0].last_seen,
        scanCount: localData[0].scan_count
      };
    }

    // Query MalwareBazaar API
    const malwareBazaarResponse = await fetch('https://mb-api.abuse.ch/api/v1/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        query: 'get_info',
        hash: sha256Hash
      })
    });

    const malwareBazaarData = await malwareBazaarResponse.json();
    
    if (malwareBazaarData.query_status === 'ok') {
      return {
        found: true,
        source: 'malwarebazaar',
        verdict: 'malicious',
        threatInfo: malwareBazaarData.data[0],
        externalSources: {
          malwareBazaar: malwareBazaarData.data[0]
        }
      };
    }

    return {
      found: false,
      source: 'none',
      verdict: 'unknown'
    };

  } catch (error) {
    console.error('Hash check error:', error);
    return {
      found: false,
      source: 'error',
      verdict: 'unknown',
      error: error.message
    };
  }
}

async function performHeuristicAnalysis(fileName: string, fileSize: number) {
  const results = {
    riskScore: 0,
    flags: [],
    details: {}
  };

  const extension = getFileExtension(fileName).toLowerCase();
  const name = fileName.toLowerCase();

  // File extension analysis
  const highRiskExtensions = ['exe', 'bat', 'cmd', 'scr', 'pif', 'com', 'msi'];
  const mediumRiskExtensions = ['js', 'vbs', 'ps1', 'sh', 'py', 'pl', 'jar'];
  const lowRiskExtensions = ['zip', 'rar', '7z', 'tar', 'gz'];

  if (highRiskExtensions.includes(extension)) {
    results.riskScore += 6;
    results.flags.push(`High-risk executable extension: .${extension}`);
  } else if (mediumRiskExtensions.includes(extension)) {
    results.riskScore += 3;
    results.flags.push(`Script file extension: .${extension}`);
  } else if (lowRiskExtensions.includes(extension)) {
    results.riskScore += 1;
    results.flags.push(`Archive file extension: .${extension}`);
  }

  // Filename analysis
  const suspiciousPatterns = [
    'temp', 'tmp', 'test', 'crack', 'keygen', 'patch', 'hack', 'trojan', 'virus'
  ];

  for (const pattern of suspiciousPatterns) {
    if (name.includes(pattern)) {
      results.riskScore += 2;
      results.flags.push(`Suspicious filename pattern: ${pattern}`);
    }
  }

  // File size analysis
  if (fileSize < 1024) {
    results.riskScore += 1;
    results.flags.push('Unusually small file size');
  } else if (fileSize > 100 * 1024 * 1024) {
    results.riskScore += 2;
    results.flags.push('Very large file size');
  }

  results.details = {
    fileName,
    fileSize,
    extension,
    analysisTime: new Date().toISOString()
  };

  return results;
}

async function performStaticAnalysis(supabase: any, fileContent: string, fileName: string) {
  const results = {
    riskScore: 0,
    flags: [],
    detectedPatterns: []
  };

  if (!fileContent) {
    return {
      riskScore: 0,
      flags: ['No file content available for static analysis'],
      detectedPatterns: []
    };
  }

  // Get threat signatures from database
  const { data: signatures } = await supabase
    .from('threat_signatures')
    .select('*')
    .eq('threat_type', 'static');

  if (signatures) {
    for (const signature of signatures) {
      const regex = new RegExp(signature.pattern, 'gi');
      const matches = fileContent.match(regex);
      
      if (matches) {
        const severityScore = getSeverityScore(signature.severity);
        results.riskScore += severityScore;
        results.flags.push(`${signature.signature_name}: ${signature.description}`);
        results.detectedPatterns.push({
          name: signature.signature_name,
          pattern: signature.pattern,
          matches: matches.length,
          severity: signature.severity
        });
      }
    }
  }

  return results;
}

async function performBehavioralAnalysis(sha256Hash: string) {
  try {
    const apiKey = Deno.env.get('HYBRID_ANALYSIS_API_KEY');
    
    if (!apiKey) {
      console.warn('HYBRID_ANALYSIS_API_KEY not configured, using fallback analysis');
      return {
        found: false,
        verdict: 'unknown',
        note: 'External behavioral analysis not available - using local heuristics'
      };
    }

    if (apiKey === 'your-hybrid-analysis-api-key-here') {
      console.warn('HYBRID_ANALYSIS_API_KEY is still using placeholder value');
      return {
        found: false,
        verdict: 'unknown',
        note: 'Please configure your Hybrid Analysis API key'
      };
    }
    
    // Query Hybrid Analysis for existing reports
    const response = await fetch(`https://www.hybrid-analysis.com/api/v2/search/hash`, {
      method: 'POST',
      headers: {
        'api-key': apiKey,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        hash: sha256Hash
      })
    });

    if (response.ok) {
      const data = await response.json();
      
      if (data && data.length > 0) {
        const report = data[0];
        return {
          found: true,
          verdict: report.verdict || 'unknown',
          threatScore: report.threat_score || 0,
          analysisDate: report.analysis_start_time,
          behaviors: report.extracted_files || [],
          networkActivity: report.network_activity || [],
          processes: report.processes || [],
          note: 'External behavioral analysis available'
        };
      }
    }

    return {
      found: false,
      verdict: 'unknown',
      note: 'No external behavioral analysis available'
    };

  } catch (error) {
    console.error('Behavioral analysis error:', error);
    return {
      found: false,
      verdict: 'error',
      error: error.message
    };
  }
}

function determineBehavioralVerdict(hashCheck: any, heuristic: any, staticAnalysis: any, overallVerdict: string): string {
  // If hash is found in malware database, it's definitely malicious
  if (hashCheck.found && hashCheck.verdict === 'malicious') {
    return 'malicious';
  }

  // If static analysis found malicious patterns
  if (staticAnalysis.detectedPatterns && staticAnalysis.detectedPatterns.length > 0) {
    const criticalPatterns = staticAnalysis.detectedPatterns.filter(p => p.severity === 'critical' || p.severity === 'high');
    if (criticalPatterns.length > 0) {
      return 'malicious';
    }
  }

  // If heuristic analysis shows high risk
  if (heuristic.riskScore >= 6) {
    return 'suspicious';
  }

  // Use overall verdict as fallback
  if (overallVerdict === 'critical' || overallVerdict === 'malicious') {
    return 'malicious';
  } else if (overallVerdict === 'suspicious') {
    return 'suspicious';
  }

  return 'safe';
}

function calculateThreatScore(hashCheck: any, heuristic: any, staticAnalysis: any, behavioral: any): number {
  let score = 0;

  // Hash check contributes heavily to score
  if (hashCheck.found && hashCheck.verdict === 'malicious') {
    score += 80;
  }

  // Heuristic analysis
  score += Math.min(heuristic.riskScore * 2, 20);

  // Static analysis
  score += Math.min(staticAnalysis.riskScore, 30);

  // Behavioral analysis
  if (behavioral.found && behavioral.threatScore) {
    score += Math.min(behavioral.threatScore, 40);
  }

  return Math.min(score, 100);
}

function determineVerdict(threatScore: number): 'safe' | 'suspicious' | 'malicious' | 'critical' {
  if (threatScore >= 80) return 'critical';
  if (threatScore >= 60) return 'malicious';
  if (threatScore >= 30) return 'suspicious';
  return 'safe';
}

function getFileExtension(fileName: string): string {
  const parts = fileName.split('.');
  return parts.length > 1 ? parts[parts.length - 1] : '';
}

function getSeverityScore(severity: string): number {
  const scores = {
    'low': 1,
    'medium': 3,
    'high': 6,
    'critical': 10
  };
  return scores[severity] || 0;
}